<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building a Complete Observability Stack: Prometheus, Grafana, ELK, and Jaeger</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            color: #24292e;
            margin: 0;
            padding: 0;
            background-color: #ffffff;
            font-size: 16px;
        }
        .container {
            max-width: 680px;
            margin: 0 auto;
            padding: 20px;
        }
        h1 {
            color: #24292e;
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 24px;
            line-height: 1.2;
            letter-spacing: -0.02em;
        }
        h2 {
            color: #24292e;
            font-size: 1.8em;
            font-weight: 600;
            margin-top: 48px;
            margin-bottom: 16px;
            line-height: 1.3;
        }
        h3 {
            color: #24292e;
            font-size: 1.4em;
            font-weight: 600;
            margin-top: 32px;
            margin-bottom: 12px;
            line-height: 1.4;
        }
        h4 {
            color: #24292e;
            font-size: 1.2em;
            font-weight: 600;
            margin-top: 24px;
            margin-bottom: 8px;
        }
        p {
            margin-bottom: 16px;
            line-height: 1.7;
        }
        .highlight {
            background: #f6f8fa;
            border: 1px solid #e1e4e8;
            padding: 24px;
            margin: 32px 0;
            border-radius: 6px;
        }
        .highlight h2 {
            color: #24292e;
            margin-bottom: 12px;
        }
        .tech-stack {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin: 32px 0;
        }
        .tech-item {
            background: #f6f8fa;
            padding: 20px;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
            text-align: center;
        }
        .tech-item h4 {
            margin: 0 0 8px 0;
            color: #24292e;
            font-weight: 600;
        }
        .architecture {
            background: #f6f8fa;
            padding: 20px;
            border-radius: 6px;
            margin: 24px 0;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            white-space: pre-wrap;
            overflow-x: auto;
            border: 1px solid #e1e4e8;
            font-size: 14px;
            line-height: 1.5;
        }
        code {
            background: #f6f8fa;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            color: #d73a49;
            font-size: 0.9em;
            border: 1px solid #e1e4e8;
        }
        pre {
            background: #f6f8fa;
            color: #24292e;
            padding: 16px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 24px 0;
            border: 1px solid #e1e4e8;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
        }
        pre code {
            background: none;
            color: inherit;
            padding: 0;
            border: none;
        }
        .warning {
            background: #fff8dc;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 16px;
            border-radius: 6px;
            margin: 24px 0;
        }
        .success {
            background: #f0f8f0;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 16px;
            border-radius: 6px;
            margin: 24px 0;
        }
        .url-list {
            background: #f6f8fa;
            padding: 20px;
            border-radius: 6px;
            margin: 24px 0;
            border: 1px solid #e1e4e8;
        }
        .url-list a {
            color: #0366d6;
            text-decoration: none;
            display: block;
            padding: 8px 0;
            border-bottom: 1px solid #e1e4e8;
            font-weight: 500;
        }
        .url-list a:last-child {
            border-bottom: none;
        }
        .url-list a:hover {
            color: #0256cc;
        }
        .troubleshooting {
            background: #f6f8fa;
            border: 1px solid #e1e4e8;
            padding: 24px;
            border-radius: 6px;
            margin: 32px 0;
        }
        .troubleshooting h3 {
            color: #24292e;
            margin-top: 0;
            margin-bottom: 20px;
        }
        .issue {
            background: #fff5f5;
            border: 1px solid #fed7d7;
            padding: 16px;
            margin: 16px 0;
            border-radius: 6px;
        }
        .issue h4 {
            color: #c53030;
            margin: 0 0 8px 0;
            font-size: 1.1em;
        }
        .issue p {
            margin: 0;
            font-size: 0.95em;
            line-height: 1.5;
        }
        .solution {
            background: #f0fff4;
            border: 1px solid #c6f6d5;
            padding: 16px;
            margin: 16px 0;
            border-radius: 6px;
        }
        .solution h4 {
            color: #38a169;
            margin: 0 0 8px 0;
            font-size: 1.1em;
        }
        .solution p {
            margin: 0;
            font-size: 0.95em;
            line-height: 1.5;
        }
        .repo-link {
            text-align: center;
            margin: 48px 0;
        }
        .repo-link a {
            background: #0366d6;
            color: white;
            padding: 12px 24px;
            text-decoration: none;
            border-radius: 6px;
            display: inline-block;
            font-weight: 600;
            transition: background 0.2s;
        }
        .repo-link a:hover {
            background: #0256cc;
        }
        
        .image-container {
            margin: 32px 0;
            text-align: center;
        }
        
        .blog-image {
            max-width: 100%;
            height: auto;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        

        
        ul, ol {
            padding-left: 24px;
            margin-bottom: 16px;
        }
        
        li {
            margin-bottom: 8px;
            line-height: 1.6;
        }
        
        blockquote {
            border-left: 4px solid #dfe2e5;
            padding-left: 16px;
            margin: 24px 0;
            color: #6a737d;
            font-style: italic;
        }
        
        .author-info {
            margin: 32px 0;
            padding: 20px;
            background: #f6f8fa;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
        }
        
        .author-info h4 {
            margin: 0 0 12px 0;
            color: #24292e;
        }
        
        .author-info p {
            margin: 0;
            color: #586069;
            font-size: 0.95em;
        }
        
        a {
            color: #0366d6;
            text-decoration: none;
            transition: color 0.2s;
        }
        
        a:hover {
            color: #0256cc;
            text-decoration: underline;
        }
        
        .links-section {
            background: #f6f8fa;
            border: 1px solid #e1e4e8;
            padding: 16px;
            margin: 24px 0;
            border-radius: 6px;
        }
        
        .links-section strong {
            color: #24292e;
        }
    </style>
    </style>
</head>
<body>
    <div class="container">
        <h1>Observability: Logs, Metrics & Magic</h1>
        
        <p>I spent three days building a complete observability system from scratch. Though I have used systems like Newrelic, which is a closed source, proprietary system, I wanted to understand how it works under the hood. These are the open source tools I have used.</p>
        
        <div class="image-container">
            <img src="UI.png" alt="Shipment tracking application user interface" class="blog-image">
        </div>

        <h2>Starting with Prometheus and viewing on Grafana</h2>

        <p>I began with Prometheus because everyone talks about it. It's a time-series database that collects metrics from your application.</p>
        
        <p>Prometheus is a time-series database that pulls metrics from your services using HTTP endpoints. It stores data in a custom format optimized for time-series queries and uses a pull-based model where it scrapes metrics from configured targets. The data is stored locally on disk with compression and retention policies.</p>
        
        <p>I added a <code>/metrics</code> endpoint to my Node.js backend that exposes HTTP request counters and response times. Prometheus scrapes this endpoint every few seconds and stores the data. I have writen code in Node.js(javascript). There is client called prom-client that can be used to expose metrics for Prometheus to scrape.</p> 
        
        <div class="links-section">
            <p><strong>Links:</strong> <a href="https://prometheus.io/docs/introduction/overview/" target="_blank">Prometheus Overview</a> | <a href="https://prometheus.io/docs/concepts/data_model/" target="_blank">Data Model</a> | <a href="https://prometheus.io/docs/prometheus/latest/storage/" target="_blank">Storage</a></p>
        </div>
        
        <div class="image-container">
            <img src="prometheus-metrics.png" alt="Prometheus metrics dashboard" class="blog-image">
        </div>

        <p>Grafana creates beautiful dashboards from your data. It queries Prometheus and displays metrics as charts and graphs.</p>
        
        <p>Grafana is a visualization and analytics platform that connects to multiple data sources including Prometheus. It provides a web interface for creating dashboards with panels, alerts, and user management. Grafana doesn't store data itself - it queries external data sources and caches results for performance.</p>
        
        <p>I took sometime understanding how to create graphana dashboards. Make sure to add Prometheus as the data source. Using PromQl queries, I was able to create a dashboard that shows the metrics I am interested in. I have created a dashboard that shows the number of requests and the response time.</p>
        
        <div class="image-container">
            <img src="grafana_dashboard.png" alt="Grafana dashboard showing shipment tracking metrics" class="blog-image">
        </div>
        <div class="links-section">
            <p><strong>Links:</strong> <a href="https://grafana.com/docs/grafana/latest/getting-started/" target="_blank">Grafana Getting Started</a> | <a href="https://www.elastic.co/guide/index.html" target="_blank">Elasticsearch Guide</a> | <a href="https://www.elastic.co/guide/en/logstash/current/introduction.html" target="_blank">Logstash Guide</a> | <a href="https://www.elastic.co/guide/en/kibana/current/introduction.html" target="_blank">Kibana Guide</a></p>
        </div>
        
        
        <p> I have docker compose file to run all these services, otherwise it is cumbersome to handle each one of them.</p>

        <h2>Adding ELK Stack</h2>
        
        <p>For logging, I used the ELK stack (Elasticsearch, Logstash, Kibana). My backend sends structured logs to Logstash via Winston HTTP transport, which processes them and stores them in Elasticsearch. Kibana provides the search interface.</p>
        
        <p>Elasticsearch is a distributed search and analytics engine built on Apache Lucene. It stores logs as JSON documents in indices and provides powerful full-text search capabilities with inverted indexes. Logstash acts as a data processing pipeline that ingests logs from multiple sources, transforms them using filters, and sends them to Elasticsearch. Kibana provides a web interface for searching, viewing, and analyzing logs stored in Elasticsearch with features like saved searches, visualizations, and dashboards.</p>
        
        <p>I ran into Docker port mapping confusion - trying to connect to <code>localhost:3000</code> instead of <code>localhost:9302</code>. I created a systematic port mapping system and documented it clearly.</p>
                
        <p>Logstash was processing my Winston logs as raw JSON instead of structured fields. I updated the code to extract nested JSON from HTTP requests and map the fields properly. I have used winston library for logging in my backend. I have used winston-transport-http to send logs to logstash. We can Kibana to view the logs by creating a data view using discover option and kibana dev tools to query the elastic search.</p>
        
        <div class="image-container">
            <img src="Kibana logs.png" alt="Kibana logs interface showing structured log data" class="blog-image">
        </div>
        
        <div class="image-container">
            <img src="Kibana Dev tools.png" alt="Kibana Dev Tools for querying Elasticsearch" class="blog-image">
        </div>

        
        <h2>Distributed Tracing with Jaeger</h2>
        
        <p>OpenTelemetry automatically instruments HTTP requests and tracks their journey through your system. Jaeger visualizes these traces and shows you exactly how long each operation takes.</p>
        
        <p>OpenTelemetry provides a vendor-neutral standard for collecting traces, metrics, and logs. It automatically instruments your Node.js application to capture request flows, database calls, and external API calls. The instrumentation creates spans that represent units of work and links them together to form traces. Jaeger is a distributed tracing system that receives traces from OpenTelemetry, stores them in a backend database (like Elasticsearch or Cassandra), and provides a UI for querying and visualizing trace data to understand request flows across microservices.</p>
        
        <p>I added custom tracing to my shipment tracking service to monitor business logic performance. The traces show middleware operations, custom spans, and HTTP context like status codes and response times.</p>
        
        <div class="image-container">
            <img src="jaeger-ui-screenshot.png" alt="Jaeger UI showing distributed traces overview" class="blog-image">
        </div>
        
        <div class="image-container">
            <img src="jaeger-trace-detail.png" alt="Detailed Jaeger trace showing backend operation breakdown" class="blog-image">
        </div>
        
        <div class="links-section">
            <p><strong>Links:</strong> <a href="https://opentelemetry.io/docs/" target="_blank">OpenTelemetry Docs</a> | <a href="https://opentelemetry.io/docs/concepts/signals/traces/" target="_blank">Traces Concepts</a> | <a href="https://www.jaegertracing.io/docs/" target="_blank">Jaeger Documentation</a> | <a href="https://www.jaegertracing.io/docs/architecture/" target="_blank">Jaeger Architecture</a></p>
        </div>
        
        <p>Docker build cache issues prevented my code changes from taking effect. I had to clean everything with <code>docker system prune -f</code> and rebuild from scratch.</p>
        
        <p>Import path errors caused module resolution failures. I fixed the relative paths and updated package.json entry points to point to the correct source files.</p>

        <h2>What I Learned</h2>
        
        <p>Start simple. Don't try to do everything at once. Begin with basic metrics, then add logging, then tracing.</p>
        
        <p>Use health checks. Add <code>/health</code> endpoints to your services - they're lifesavers for debugging.</p>
        
        <p>Plan your ports. Use a system for port mapping. I used 9300s for UI, 9200s for data.</p>
        
        <p>Test everything. Create simple test scripts to verify your setup works.</p>
        
        <p>Write things down. Document what you're doing - you'll forget the details later.</p>
        
        <p>Expect things to break. Your monitoring system should keep working even if parts of it fail.</p>

        <h2>Getting Started</h2>
        
        <p>To run this yourself:</p>
        
        <pre><code>git clone [your-repo]
cd observability
docker-compose up --build</code></pre>
        
        <p>Then visit:</p>
        <ul>
            <li>Frontend: http://localhost:9301</li>
            <li>Grafana: http://localhost:9300</li>
            <li>Kibana: http://localhost:9601</li>
            <li>Jaeger: http://localhost:17686</li>
        </ul>

        <div class="repo-link">
            <a href="https://github.com/yourusername/observability-demo" target="_blank">
                Get the Complete Code on GitHub
            </a>
        </div>

        <blockquote>
            <p>This project represents three days of intense development, debugging, and learning. The issues documented here are real problems I encountered and solved. I'm sharing this because I wish I had a guide like this when I started!</p>
        </blockquote>

        <div class="author-info">
            <h4>About the Author</h4>
            <p>A developer passionate about observability and distributed systems. This project was built as a learning exercise to understand how monitoring, logging, and tracing work together in modern applications.</p>
        </div>
    </div>
</body>
</html> 